// container-assets/main.c
//
// Embeds CBOR test files into the binary (headers generated at build time)
// and extracts them to the runtime filesystem if missing.
//
// Behavior:
//  - Default output root: /testing (override via argv[1])
//  - Creates directories as needed (mkdir -p)
//  - For each embedded file: if missing, write it out; if present, do nothing
//  - On any filesystem error: print and exit(1)

#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include <ocre_api.h>

#ifndef LOG_PREFIX
#define LOG_PREFIX "[ASSETS] "
#endif

#ifndef ASSET_OUTPUT_ROOT_DEFAULT
#define ASSET_OUTPUT_ROOT_DEFAULT "/testing"
#endif

// This header is generated by CMake and includes one header per asset.
#include "embedded_assets.h"

static void die(const char *msg, const char *path) {
    if (path) {
        printf(LOG_PREFIX "ERROR: %s: %s (errno=%d: %s)\n", msg, path, errno, strerror(errno));
    } else {
        printf(LOG_PREFIX "ERROR: %s (errno=%d: %s)\n", msg, errno, strerror(errno));
    }
    exit(1);
}

static int path_is_dir(const char *path) {
    struct stat st;
    if (stat(path, &st) != 0) return 0;
    return S_ISDIR(st.st_mode) ? 1 : 0;
}

static int path_exists(const char *path) {
    struct stat st;
    return (stat(path, &st) == 0);
}

// mkdir -p for POSIX-ish environments (WASI typically supports mkdir/stat)
static void mkdir_p(const char *path) {
    if (!path || !*path) return;

    // If already a dir, done
    if (path_is_dir(path)) return;

    char tmp[512];
    size_t n = strlen(path);
    if (n >= sizeof(tmp)) {
        errno = ENAMETOOLONG;
        die("path too long", path);
    }
    memcpy(tmp, path, n + 1);

    // Walk and create segments
    for (char *p = tmp + 1; *p; p++) {
        if (*p == '/') {
            *p = '\0';
            if (*tmp && !path_is_dir(tmp)) {
                if (mkdir(tmp, 0777) != 0 && errno != EEXIST) {
                    die("mkdir failed", tmp);
                }
            }
            *p = '/';
        }
    }

    if (!path_is_dir(tmp)) {
        if (mkdir(tmp, 0777) != 0 && errno != EEXIST) {
            die("mkdir failed", tmp);
        }
    }
}

static void ensure_parent_dir(const char *full_path) {
    // Create parent directory of full_path (everything up to last '/')
    const char *slash = strrchr(full_path, '/');
    if (!slash) return;

    size_t len = (size_t)(slash - full_path);
    if (len == 0) return; // parent is "/"

    char parent[512];
    if (len >= sizeof(parent)) {
        errno = ENAMETOOLONG;
        die("parent path too long", full_path);
    }
    memcpy(parent, full_path, len);
    parent[len] = '\0';

    mkdir_p(parent);
}

static void write_file_atomicish(const char *path, const uint8_t *data, size_t len) {
    FILE *f = fopen(path, "wb");
    if (!f) die("fopen(wb) failed", path);

    if (len > 0) {
        size_t nw = fwrite(data, 1, len, f);
        if (nw != len) {
            fclose(f);
            die("short write", path);
        }
    }

    if (fclose(f) != 0) die("fclose failed", path);
}

static void join_path(char *out, size_t out_sz, const char *root, const char *rel) {
    // root expected like "/testing" (no trailing slash required)
    // rel expected like "idle.1.cbor....cbor" or "testing/idle..." (we'll strip leading '/')
    while (*rel == '/') rel++;

    int n = snprintf(out, out_sz, "%s/%s", root, rel);
    if (n <= 0 || (size_t)n >= out_sz) {
        errno = ENAMETOOLONG;
        die("joined path too long", NULL);
    }
}

int main(int argc, char **argv) {
    setvbuf(stdout, NULL, _IONBF, 0);

    const char *out_root = (argc > 1 && argv[1] && argv[1][0]) ? argv[1] : ASSET_OUTPUT_ROOT_DEFAULT;

    printf(LOG_PREFIX "Starting asset extractor\n");
    printf(LOG_PREFIX "Output root: %s\n", out_root);
    printf(LOG_PREFIX "Embedded assets: %zu file(s)\n", embedded_assets_count);

    // Ensure root exists
    mkdir_p(out_root);

    for (size_t i = 0; i < embedded_assets_count; i++) {
        const embedded_asset_t *a = &embedded_assets[i];

        char out_path[512];
        join_path(out_path, sizeof(out_path), out_root, a->rel_path);

        if (path_exists(out_path)) {
            // Present -> do nothing
            continue;
        }

        ensure_parent_dir(out_path);

        printf(LOG_PREFIX "Extracting %s (%zu bytes) -> %s\n",
               a->rel_path, a->size, out_path);

        write_file_atomicish(out_path, a->data, a->size);
    }

    printf(LOG_PREFIX "Done\n");
    return 0;
}
