/*
 * CBOR Test Asset Extractor
 *
 * This module embeds CBOR test files into the binary and extracts them to the
 * runtime filesystem at startup. Embedded asset headers are generated by CMake
 * at build time and included via embedded_assets.h.
 *
 * Behavior:
 *  - Output root directory: /testing (configurable via argv[1])
 *  - Creates all necessary directories recursively
 *  - For each embedded file: extracts if missing, skips if present
 *  - Terminates with error code 1 on any filesystem operation failure
 */

#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include <ocre_api.h>

#ifndef LOG_PREFIX
#define LOG_PREFIX "[ASSETS] "
#endif

/** Default output root directory for extracted assets. */
#ifndef ASSET_OUTPUT_ROOT_DEFAULT
#define ASSET_OUTPUT_ROOT_DEFAULT "/testing"
#endif

/* Embedded asset headers generated by CMake. */
#include "embedded_assets.h"

/* ============================================================================
 * Error Handling
 * ============================================================================ */

/**
 * Print an error message and exit with status code 1.
 *
 * @param msg  Error message description
 * @param path Optional file path associated with the error
 */
static void die(const char *msg, const char *path) {
    if (path) {
        printf(LOG_PREFIX "ERROR: %s: %s (errno=%d: %s)\n", msg, path, errno, strerror(errno));
    } else {
        printf(LOG_PREFIX "ERROR: %s (errno=%d: %s)\n", msg, errno, strerror(errno));
    }
    exit(1);
}

/* ============================================================================
 * Filesystem Utilities
 * ============================================================================ */

/**
 * Check if a path exists and is a directory.
 *
 * @param path Path to check
 * @return 1 if path is a directory, 0 otherwise
 */
static int path_is_dir(const char *path) {
    struct stat st;
    if (stat(path, &st) != 0) return 0;
    return S_ISDIR(st.st_mode) ? 1 : 0;
}

/**
 * Check if a path exists (file or directory).
 *
 * @param path Path to check
 * @return 1 if path exists, 0 otherwise
 */
static int path_exists(const char *path) {
    struct stat st;
    return (stat(path, &st) == 0);
}

/**
 * Create directory and all parent directories as needed (mkdir -p).
 *
 * Similar to the POSIX mkdir -p command. Handles intermediate directory
 * creation and gracefully handles existing directories.
 *
 * @param path Directory path to create
 */
static void mkdir_p(const char *path) {
    if (!path || !*path) return;

    // If already a dir, done
    if (path_is_dir(path)) return;

    char tmp[512];
    size_t n = strlen(path);
    if (n >= sizeof(tmp)) {
        errno = ENAMETOOLONG;
        die("path too long", path);
    }
    memcpy(tmp, path, n + 1);

    // Walk and create segments
    for (char *p = tmp + 1; *p; p++) {
        if (*p == '/') {
            *p = '\0';
            if (*tmp && !path_is_dir(tmp)) {
                if (mkdir(tmp, 0777) != 0 && errno != EEXIST) {
                    die("mkdir failed", tmp);
                }
            }
            *p = '/';
        }
    }

    if (!path_is_dir(tmp)) {
        if (mkdir(tmp, 0777) != 0 && errno != EEXIST) {
            die("mkdir failed", tmp);
        }
    }
}

/**
 * Create all parent directories for a given file path.
 *
 * Extracts the parent directory from a full file path and ensures it exists,
 * creating intermediate directories as needed.
 *
 * @param full_path Full file path whose parent directories should be created
 */
static void ensure_parent_dir(const char *full_path) {
    // Create parent directory of full_path (everything up to last '/')
    const char *slash = strrchr(full_path, '/');
    if (!slash) return;

    size_t len = (size_t)(slash - full_path);
    if (len == 0) return; // parent is "/"

    char parent[512];
    if (len >= sizeof(parent)) {
        errno = ENAMETOOLONG;
        die("parent path too long", full_path);
    }
    memcpy(parent, full_path, len);
    parent[len] = '\0';

    mkdir_p(parent);
}

/**
 * Write binary data to a file.
 *
 * Opens the file in binary write mode, writes the complete data buffer,
 * and closes the file. Exits with error on any write failure.
 *
 * @param path File path to write to
 * @param data Pointer to binary data
 * @param len  Number of bytes to write
 */
static void write_file_atomicish(const char *path, const uint8_t *data, size_t len) {
    FILE *f = fopen(path, "wb");
    if (!f) die("fopen(wb) failed", path);

    if (len > 0) {
        size_t nw = fwrite(data, 1, len, f);
        if (nw != len) {
            fclose(f);
            die("short write", path);
        }
    }

    if (fclose(f) != 0) die("fclose failed", path);
}

/**
 * Join a root directory path with a relative path.
 *
 * Creates a full path by combining a root directory with a relative path
 * component. Handles leading slashes in the relative path.
 *
 * @param out    Output buffer for the joined path
 * @param out_sz Size of output buffer
 * @param root   Root directory path (e.g., "/testing")
 * @param rel    Relative path component (leading '/' characters are stripped)
 */
static void join_path(char *out, size_t out_sz, const char *root, const char *rel) {
    // root expected like "/testing" (no trailing slash required)
    // rel expected like "idle.1.cbor....cbor" or "testing/idle..." (we'll strip leading '/')
    while (*rel == '/') rel++;

    int n = snprintf(out, out_sz, "%s/%s", root, rel);
    if (n <= 0 || (size_t)n >= out_sz) {
        errno = ENAMETOOLONG;
        die("joined path too long", NULL);
    }
}

/* ============================================================================
 * Main Entry Point
 * ============================================================================ */

/**
 * Main entry point for the asset extractor.
 *
 * Iterates through all embedded assets and extracts them to the filesystem
 * if they do not already exist. Creates all necessary parent directories
 * automatically.
 *
 * @param argc Argument count
 * @param argv Argument vector; argv[1] optionally specifies output root directory
 *
 * @return 0 on successful extraction of all assets, 1 on error
 */
int main(int argc, char **argv) {
    setvbuf(stdout, NULL, _IONBF, 0);

    /* Get output root from command line or use default. */
    const char *out_root = (argc > 1 && argv[1] && argv[1][0]) ? argv[1] : ASSET_OUTPUT_ROOT_DEFAULT;

    printf(LOG_PREFIX "Starting asset extractor\n");
    printf(LOG_PREFIX "Output root: %s\n", out_root);
    printf(LOG_PREFIX "Embedded assets: %zu file(s)\n", embedded_assets_count);

    /* Ensure root exists. */
    mkdir_p(out_root);

    /* Extract each embedded asset if not already present. */
    for (size_t i = 0; i < embedded_assets_count; i++) {
        const embedded_asset_t *a = &embedded_assets[i];

        char out_path[512];
        join_path(out_path, sizeof(out_path), out_root, a->rel_path);

        /* Skip if file already exists. */
        if (path_exists(out_path)) {
            // Present -> do nothing
            continue;
        }

        ensure_parent_dir(out_path);

        printf(LOG_PREFIX "Extracting %s (%zu bytes) -> %s\n",
               a->rel_path, a->size, out_path);

        write_file_atomicish(out_path, a->data, a->size);
    }

    printf(LOG_PREFIX "Done\n");
    return 0;
}
